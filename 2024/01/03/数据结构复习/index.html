
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title> | Welcome</title>
        <meta name="author" content="EzraLi" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/smile.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>WELCOME</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;WELCOME</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/1/3
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="数据结构复习"><a href="#数据结构复习" class="headerlink" title="数据结构复习"></a>数据结构复习</h1><h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h3><h4 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1.二叉树的遍历"></a>1.二叉树的遍历</h4><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;

#define MAX_TREE_SIZE 100
typedef char ElemType;

struct Node
&#123;
    ElemType data;
    struct Node *lchild,*rchild;
&#125;;

typedef struct Node* BiTNode;

void InitBitree(BiTNode &amp;T)
&#123;
    T = NULL;
&#125;

void CreatBitree(BiTNode &amp;T)
&#123;
    char a;
    cin &gt;&gt; a;
    if (a == &#39;#&#39;)
    &#123;
        T = NULL;
    &#125;
    else
    &#123;
        T = new Node;
        T-&gt;data = a;
        CreatBitree(T-&gt;lchild);
        CreatBitree(T-&gt;rchild);
    &#125;
&#125;

// 前序递归
void Pre(BiTNode T)
&#123;
    if (T != NULL)
    &#123;
        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;
        Pre(T-&gt;lchild);
        Pre(T-&gt;rchild);
    &#125;
&#125;

// 前序非递归
void Pre_nonRec(BiTNode T)
&#123;
    stack&lt;BiTNode&gt; S;
    BiTNode p = T;
    while (p != NULL || !S.empty())
    &#123;
        if (p)
        &#123;
            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
            S.push(p);
            p = p-&gt;lchild;
        &#125;
        else
        &#123;
            p = S.top();
            S.pop();
            p = p-&gt;rchild;
        &#125;
    &#125;
&#125;

// 中序递归
void Mid(BiTNode T)
&#123;
    if (T != NULL)
    &#123;
        Mid(T-&gt;lchild);
        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;
        Mid(T-&gt;rchild);
    &#125;
&#125;

// 非递归中序
void Mid_nonRec(BiTNode T)
&#123;
    stack&lt;BiTNode&gt; S;
    BiTNode p = T;
    while (p != NULL || !S.empty())
    &#123;
        if (p)
        &#123;
            S.push(p);
            p = p-&gt;lchild;
        &#125;
        else
        &#123;
            p = S.top();
            S.pop();
            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
            p = p-&gt;rchild;
        &#125;
    &#125;
&#125;

// 后序递归
void End(BiTNode T)
&#123;
    if (T != NULL)
    &#123;
        End(T-&gt;lchild);
        End(T-&gt;rchild);
        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;
    &#125;
&#125;

int main()
&#123;
    BiTNode T;
    InitBitree(T);
    
    CreatBitree(T);
 
    cout &lt;&lt; &quot;前序：&quot;;
    Pre(T);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;非递归前序：&quot;;
    Pre_nonRec(T);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;中序：&quot;;
    Mid(T);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;非递归中序：&quot;;
    Mid_nonRec(T);
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;后序：&quot;;
    End(T);
    cout &lt;&lt; endl;

    delete[] T;
    return 0;
&#125;

// abdg##h###ce#i##f##
</code></pre>
<h4 id="2-层次遍历"><a href="#2-层次遍历" class="headerlink" title="2.层次遍历"></a>2.层次遍历</h4><pre><code class="c++">// 层次遍历
void cengcibianli(BiTNode T)
&#123;
    if (T != NULL)
    &#123;
        queue&lt;BiTNode&gt; S;
        BiTNode p;

        S.push(T);

        while (!S.empty())
        &#123;
            p = S.front();
            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
            S.pop();

            if(p-&gt;lchild != NULL)
            &#123;
                S.push(p-&gt;lchild);
            &#125;
            if(p-&gt;rchild != NULL)
            &#123;
                S.push(p-&gt;rchild);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="3-由遍历序列构造二叉树"><a href="#3-由遍历序列构造二叉树" class="headerlink" title="3.由遍历序列构造二叉树"></a>3.由遍历序列构造二叉树</h4><p>1.前序+中序</p>
<p>2.后序+中序</p>
<h4 id="4-哈夫曼树"><a href="#4-哈夫曼树" class="headerlink" title="4.哈夫曼树"></a>4.哈夫曼树</h4><p>（1）<strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径<br>（2）<strong>路径长度</strong>：路径上的分支数目称作路径长度。<br>（3）<strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。<br>（4）<strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<br>（5）<strong>结点的带权路径长度</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积<br>（6）<strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和。</p>
<ul>
<li>哈夫曼树：最优二叉树（带权路径长度（WPL）最短的二叉树） ，带权路径长度最短是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称。</li>
<li>满二叉树不一定是哈夫曼树</li>
<li>哈夫曼树中权越大的叶子离根越近</li>
<li>具有相同带权结点的哈夫曼树不唯一</li>
</ul>
<h4 id="5-哈夫曼树构造方法"><a href="#5-哈夫曼树构造方法" class="headerlink" title="5.哈夫曼树构造方法"></a>5.哈夫曼树构造方法</h4><p>典型的贪心算法：构造哈夫曼树时首先选择权值小的叶子结点。</p>
<p>哈夫曼算法（构造哈夫曼树的方法）</p>
<p>（1）根据n个给定的权值{w1,w2,w3…，wn}构成n棵二叉树的森林F&#x3D;{T1,T2,…,Tn},其中，Ti只有一个带权为wi的根结点。</p>
<p>​          <strong>构造森林全是根</strong></p>
<p>（2）在F中选取两棵根结点的权值最小的数作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结</p>
<p>​         点的权值之和</p>
<p>​         <strong>选用两小造新树</strong></p>
<p>（3）在F中删除这两棵树，同时将新得到的二叉树加入森林中。</p>
<p>​          <strong>删除两小添新人</strong></p>
<p>（4）重复（2）和（3），直到森林中只有一棵树为止，这棵树即为哈夫曼树。</p>
<p>​          <strong>重复2、3剩单根</strong></p>
<p><img src="E:\数据结构\期末复习\Huffman_tree.png" alt="图片"></p>
<h4 id="6-二叉排序树"><a href="#6-二叉排序树" class="headerlink" title="6.二叉排序树"></a>6.二叉排序树</h4><p>二叉排序树(也称二叉查找树)或者是一棵空树，或者是具有下列特性的二叉树:</p>
<ul>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li>
<li>左、右子树也分别是一棵二叉排序树。</li>
</ul>
<p>根据二叉排序树的定义，左子树结点值&lt;根结点值&lt;右子树结点值，所以对二叉排序树进行<strong>中序遍历</strong>，可以得到一个递增的有序序列。</p>
<p><img src="E:\数据结构\期末复习\Bitree.png" alt="图片"></p>
<pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

#define MAX_TREE_SIZE 100
typedef int ElemType;

struct Node
&#123;
    ElemType data;
    struct Node *lchild,*rchild;
&#125;;

typedef struct Node *BiTNode;

bool Delete(BiTNode *T);

void InitBitree(BiTNode &amp;T)
&#123;
    T = NULL;
&#125;

// 查找
bool searchBST(BiTNode T, int key, BiTNode f, BiTNode *p)
&#123;
    /*
    递归查找二叉排序树T中是否存在key
    指针f指向T的双亲，其初始调用值为NULL
    若查找成功，则指针p指向该数据元素结点，并返回TRUE
    否则指针p指向查找路径上访问的最后一个结点并返回FALSE
    */
    if(T == NULL)
    &#123;
        *p = f;
        return false;
    &#125;
    else if (key == T-&gt;data)
    &#123;
        //查找成功
        *p = T;
        return true;
    &#125;
    else if (key &lt; T-&gt;data)
    &#123;
        return searchBST(T-&gt;lchild,key,T,p); // 在左子树继续寻找
    &#125;
    else
    &#123;
        return searchBST(T-&gt;rchild,key,T,p); // 在右子树继续寻找
    &#125;
&#125;

// 插入
bool InsertBST(BiTNode *T,int key)
&#123;
    /*
    当二叉排序树T中不存在关键字等于key的数据元素时
    插入key并返回TRUE，否则返回FALSE
    */
    BiTNode p,s;
    if (!searchBST(*T,key,NULL,&amp;p))
    &#123;
        // 查找不成功
        s = (BiTNode)malloc(sizeof(BiTNode));
        s-&gt;data = key;
        s-&gt;lchild = s-&gt;rchild = NULL;
        if(!p)
        &#123;
            *T = s; // 插入s作为新的根节点
        &#125;
        else if (key &lt; p-&gt;data)
        &#123;
            p-&gt;lchild = s; // 插入s作为左孩子
        &#125;
        else
        &#123;
            p-&gt;rchild = s; // 插入s作为又孩子
        &#125;
       
        return true;
    &#125;
    else
    &#123;
        
        return false; // 树中已有相同的关键字，不再插入
    &#125;
&#125;

// 中序遍历
void Mid(BiTNode T)
&#123;
    if (T != NULL)
    &#123;
        Mid(T-&gt;lchild);
        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;
        Mid(T-&gt;rchild);
    &#125;
&#125;

int main()
&#123;
    int a[10] = &#123;62, 88, 58, 47, 35, 73, 51, 99, 37, 93&#125;;
    BiTNode T;
    InitBitree(T);

    for (int i = 0;i &lt; 10;i++)
    &#123;
        InsertBST(&amp;T,a[i]);
    &#125;

    Mid(T);
    cout &lt;&lt; endl;
&#125;
</code></pre>
<p><img src="E:\数据结构\期末复习\Bitree1.png" alt="图片"></p>
<h3 id="二、平衡二叉树"><a href="#二、平衡二叉树" class="headerlink" title="二、平衡二叉树"></a>二、平衡二叉树</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。</strong><br>它是一种高度平衡的二叉排序树。它要么是一棵空树， 要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。**我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balance Factor) **， 那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p><img src="E:\数据结构\期末复习\Balanced_BiTree.png" alt="图片"></p>
<h4 id="2-平衡二叉树的插入"><a href="#2-平衡二叉树的插入" class="headerlink" title="2.平衡二叉树的插入"></a>2.平衡二叉树的插入</h4><h5 id="2-1最小不平衡子树"><a href="#2-1最小不平衡子树" class="headerlink" title="2.1最小不平衡子树"></a>2.1最小不平衡子树</h5><p>距离插入节点最近的，并且 BF 的绝对值大于 1 的节点为根节点的子树。</p>
<blockquote>
<p><strong>「旋转」纠正只需要纠正「最小不平衡子树」即可</strong></p>
</blockquote>
<p><img src="E:\数据结构\期末复习\Balanced_BiTree(1).png" alt="图片"></p>
<h5 id="2-2-四种「旋转」纠正类型："><a href="#2-2-四种「旋转」纠正类型：" class="headerlink" title="2.2 四种「旋转」纠正类型："></a>2.2 <strong>四种「旋转」纠正类型：</strong></h5><ol>
<li>LL 型：插入左孩子的左子树，右旋</li>
<li>RR 型：插入右孩子的右子树，左旋</li>
<li>LR 型：插入左孩子的右子树，先左旋，再右旋</li>
<li>RL 型：插入右孩子的左子树，先右旋，再左旋</li>
</ol>
<p><img src="E:\数据结构\期末复习\2e5e4517694d59e4a243a1b032d3298f.png" alt="图片"></p>
<p><strong>1. LL</strong></p>
<p><img src="E:\数据结构\期末复习\9c8fd48b40b2902e6f5d713d073cdf86.gif" alt="图片"></p>
<pre><code class="c++">AVLTree LL(AVLTree T)
&#123;
    AVLTree T1;
    T1 = T-&gt;lchild;
    T-&gt;lchild = T1-&gt;rchild;
    T1-&gt;rchild = T;
    return T1;
&#125;
</code></pre>
<p><strong>2. RR</strong></p>
<p><img src="E:\数据结构\期末复习\bc202c8af7a2fe17150674ebf9d2c80a.gif" alt="图片"></p>
<pre><code class="c++">AVLTree RR(AVLTree T)
&#123;
    AVLTree T1;
    T1 = T-&gt;rchild;
    T-&gt;rchild = T1-&gt;lchild;
    T1-&gt;lchild = T;
    return T1;
&#125;
</code></pre>
<p><strong>3. LR</strong></p>
<p><img src="E:\数据结构\期末复习\b9aa779dd28c8b668ab623cabd43cd52.gif" alt="图片"></p>
<p><img src="E:\数据结构\期末复习\9ff53c6867737534c4abcb4b37c13ce2.gif" alt="图片"></p>
<pre><code class="c++">AVLTree LR(AVLTree T)
&#123;
    T-&gt;lchild = RR(T-&gt;lchild);
    return LL(T);
&#125;
</code></pre>
<p><strong>4. RL</strong></p>
<p><img src="E:\数据结构\期末复习\edb1c2bb245ff799ac3db84d1dcf56c1.gif" alt="图片"></p>
<p><img src="E:\数据结构\期末复习\8df7ce95862e8e3cdc9d5d6f1c31ab12.gif" alt="图片"></p>
<pre><code class="c++">AVLTree RL(AVLTree T)
&#123;
    T-&gt;rchild = LL(T-&gt;rchild);
    return RR(T);
&#125;
</code></pre>
<h5 id="2-3-完整代码"><a href="#2-3-完整代码" class="headerlink" title="2.3 完整代码"></a>2.3 完整代码</h5><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;

#define MAX_TREE_SIZE 100
typedef int ElemType;

struct Node
&#123;
    ElemType data;
    struct Node *lchild,*rchild;
&#125;;

typedef struct Node *AVLTree;

void InitTree(AVLTree &amp;T)
&#123;
    T = NULL;
&#125;

int High(AVLTree T)
&#123;
    if (T == NULL)
    &#123;
        return 0;
    &#125;
    else
    &#123;
        int left = High(T-&gt;lchild) + 1;
        int right = High(T-&gt;rchild) + 1;

        return max(left,right);
    &#125;
&#125;

AVLTree LL(AVLTree T)
&#123;
    AVLTree T1;
    T1 = T-&gt;lchild;
    T-&gt;lchild = T1-&gt;rchild;
    T1-&gt;rchild = T;
    return T1;
&#125;

AVLTree RR(AVLTree T)
&#123;
    AVLTree T1;
    T1 = T-&gt;rchild;
    T-&gt;rchild = T1-&gt;lchild;
    T1-&gt;lchild = T;
    return T1;
&#125;

AVLTree LR(AVLTree T)
&#123;
    T-&gt;lchild = RR(T-&gt;lchild);
    return LL(T);
&#125;

AVLTree RL(AVLTree T)
&#123;
    T-&gt;rchild = LL(T-&gt;rchild);
    return RR(T);
&#125;

AVLTree Insert(AVLTree T, int x)
&#123;
    if (T == NULL)
    &#123;
        AVLTree T = new Node();
        T-&gt;data = x;
        T-&gt;lchild = T-&gt;rchild = NULL;
        return T;
    &#125;
    else if(x &gt; T-&gt;data)
    &#123;
        T-&gt;rchild = Insert(T-&gt;rchild,x);

        if(High(T-&gt;rchild) - High(T-&gt;lchild) &gt;= 2)
        &#123;
            if (x &gt; T-&gt;rchild-&gt;data)
            &#123;
                T = RR(T);
            &#125;
            else
            &#123;
                T = RL(T);
            &#125;
        &#125;
    &#125;
    else if(x &lt; T-&gt;data)
    &#123;
        T-&gt;lchild = Insert(T-&gt;lchild,x);

        if(High(T-&gt;lchild) - High(T-&gt;rchild) &gt;= 2)
        &#123;
            if (x &lt; T-&gt;rchild-&gt;data)
            &#123;
                T = LL(T);
            &#125;
            else
            &#123;
                T = LR(T);
            &#125;
        &#125;
    &#125;
    return T;
&#125;

void Mid(AVLTree T)
&#123;
    if (T != NULL)
    &#123;
        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;
        Mid(T-&gt;lchild);
        
        Mid(T-&gt;rchild);
    &#125;
&#125;

int main()
&#123;
    int n;
    cin &gt;&gt; n;
    int x;

    AVLTree T;
    InitTree(T);

    for (int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; x;
        T = Insert(T,x);
    &#125;

    Mid(T);
    cout &lt;&lt; endl;

    delete[] T;
    return 0;
&#125;
</code></pre>
<h3 id="三、图"><a href="#三、图" class="headerlink" title="三、图"></a>三、图</h3><h4 id="1-知识框架"><a href="#1-知识框架" class="headerlink" title="1.知识框架"></a>1.知识框架</h4><p><img src="E:\数据结构\期末复习\20210226170339905.png" alt="图片"></p>
<h4 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2.图的存储"></a>2.图的存储</h4><h5 id="2-1邻接矩阵"><a href="#2-1邻接矩阵" class="headerlink" title="2.1邻接矩阵"></a>2.1邻接矩阵</h5><p><img src="E:\数据结构\期末复习\240a83ef74eecb29fa7c9eb2feb822eb.png" alt="图片"></p>
<p><img src="E:\数据结构\期末复习\a1b8ca881452ac53d3f2149d0ae7360a.png" alt="图片"></p>
<h5 id="2-2邻接表"><a href="#2-2邻接表" class="headerlink" title="2.2邻接表"></a>2.2邻接表</h5><p><img src="E:\数据结构\期末复习\e7b8961943defbe62fa9cad4101a2f76.png" alt="图片"></p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define MAX_SIZE 100

// 邻接矩阵存储的图
struct Graph
&#123;
    int vexNumber;
    string vexInfo[MAX_SIZE];
    int adjMatrix[MAX_SIZE][MAX_SIZE];
&#125;;

// 弧节点定义
struct ArcNode
&#123;
    char weight;       // 弧节点上的信息部分
    int adj;           // 邻接点的序号
    ArcNode *nextarc;  // 下一条边
&#125;;

// 顶点节点定义
struct VexNode
&#123;
    string Info;     // 顶点上的信息部分
    ArcNode *firstarc;  // 弧链头指针
&#125;;

// 邻接表结构的图的定义
struct linkGraph
&#123;
    VexNode *vexes;  // 每个节点的邻接表
    int vexnumber;   // 节点数量
&#125;;

// 邻接表存储的图的初始化
int InitGraph(linkGraph &amp;G, int vexnumber)
&#123;
    G.vexes = new VexNode[vexnumber];
    G.vexnumber = vexnumber;
    for (int i = 0; i &lt; vexnumber; i++)
    &#123;
        G.vexes[i].firstarc = NULL;
    &#125;
    return 0;
&#125;

// 构造边节点指针
ArcNode* getArcNode(int adj)&#123;
    ArcNode* node = new ArcNode();
    node-&gt;adj = adj;
    node-&gt;nextarc = nullptr;
    return node;
&#125;
// 根据输入构造邻接表存储的图
void InputlinkGraph(linkGraph&amp; LG)&#123;
    int n;
    cin&gt;&gt;n;
    InitGraph(LG,n);
    for(int i=0;i&lt;n;i++)&#123;
        string s;
        cin&gt;&gt;s;
        LG.vexes[i].Info=s[0];
        for(int j=1;j&lt;s.size();j++)&#123;
            if(s[j]==&#39;-&#39;)continue;
            ArcNode* p= new ArcNode();
            ArcNode* a= LG.vexes[i].firstarc;
            p-&gt;nextarc=NULL;
            p-&gt;weight=s[j];
            p-&gt;adj=s[j]-&#39;a&#39;;
            if(a==NULL)LG.vexes[i].firstarc=p;
            else&#123;
                while(a-&gt;nextarc!=NULL)
                    a=a-&gt;nextarc;
                a-&gt;nextarc=p;
            &#125;
        &#125;
    &#125;
&#125;
// 将邻接表存储的图转化为邻接矩阵存储的图
void linkGraph2Graph(const linkGraph&amp; LG, Graph&amp; G)&#123;
    G.vexNumber=LG.vexnumber;
    memset(G.adjMatrix,0,sizeof(G.adjMatrix));
    for(int i=0;i&lt;LG.vexnumber;i++)&#123;
        ArcNode* p=LG.vexes[i].firstarc;
        while(p!=NULL)&#123;
            G.adjMatrix[i][p-&gt;adj]=1;
            p=p-&gt;nextarc;
        &#125;
    &#125;
&#125;
 
// 输出邻接矩阵
void printGraph(const Graph&amp; G)&#123;
    for(int i=0;i&lt;G.vexNumber;i++)&#123;
        for(int j=0;j&lt;G.vexNumber;j++)&#123;
            cout&lt;&lt;G.adjMatrix[i][j]&lt;&lt;&quot; &quot;;
        &#125;
        cout&lt;&lt;endl;
    &#125;
&#125;
 
// 输出邻接表
void PrintlinkGraph(const linkGraph&amp; G)&#123;
   for(int i=0;i&lt;G.vexnumber;i++)&#123;
       cout&lt;&lt;G.vexes[i].Info;
       ArcNode* p=G.vexes[i].firstarc;
       while(p!=NULL)&#123;
           cout&lt;&lt;&quot; --&gt; &quot;&lt;&lt;p-&gt;weight;
           p=p-&gt;nextarc;
       &#125;
       cout&lt;&lt;endl;
   &#125;
&#125;
 
// 邻接表存储的图的销毁
int DestroylinkGraph(linkGraph &amp;G)
&#123;
    for (int i = 0; i &lt; G.vexnumber; i++)
    &#123;
        while (G.vexes[i].firstarc != NULL)
        &#123;
            ArcNode *p = G.vexes[i].firstarc;
            G.vexes[i].firstarc = p-&gt;nextarc;
            delete p;
        &#125;
    &#125;
    delete[] G.vexes;
    G.vexes = NULL;
    G.vexnumber = 0;
    return 0;
&#125;
// please comment the following code when you submit to OJ
int main()&#123;
    // freopen(&quot;/config/workspace/answer/test.in&quot;,&quot;r&quot;,stdin);
    linkGraph LG;
    Graph G;
    InputlinkGraph(LG);
    PrintlinkGraph(LG);
    linkGraph2Graph(LG,G);
    printGraph(G);
    DestroylinkGraph(LG);
    return 0;
&#125;

</code></pre>
<p><strong>输入样例</strong></p>
<pre><code class="c++">7
a-g-f
b-c
c-e
d
e-d
f-g-e
g-d
</code></pre>
<p><strong>输出样例</strong></p>
<pre><code class="c++">a --&gt; g --&gt; f 
b --&gt; c 
c --&gt; e 
d 
e --&gt; d 
f --&gt; g --&gt; e 
g --&gt; d 
0 0 0 0 0 1 1 
0 0 1 0 0 0 0 
0 0 0 0 1 0 0 
0 0 0 0 0 0 0 
0 0 0 1 0 0 0 
0 0 0 0 1 0 1 
0 0 0 1 0 0 0
</code></pre>
<h4 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3.图的遍历"></a>3.图的遍历</h4><h5 id="3-1-DFS-深度优先遍历"><a href="#3-1-DFS-深度优先遍历" class="headerlink" title="3.1 DFS (深度优先遍历)"></a>3.1 DFS (深度优先遍历)</h5><pre><code class="c++">#include&lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;

using namespace std;

#define MAX_SIZE 100

struct Graph
&#123;
    int vexNumber;
    string vexInfo[MAX_SIZE];
    int adjMatrix[MAX_SIZE][MAX_SIZE];
&#125;;

// 以顶点v0为起点，进行一趟DFS
string DFS(const Graph &amp;G, int v0, int visited[])
&#123;
    string result = &quot;&quot;;
    result = result + G.vexInfo[v0] +&quot; &quot;;
    visited[v0] = 1; // 标记已经访问过的节点

    for (int i = 0; i &lt; G.vexNumber; i++)
    &#123;
        if (G.adjMatrix[v0][i] == 1 &amp;&amp; visited[i] != 1) // 当有边且该节点未被访问
        &#123;
            result = result +DFS(G,i,visited);
        &#125;
    &#125;
    return result;
&#125;

// 对整个图进行DFS
string DFS(const Graph &amp;G)
&#123;
    string result = &quot;&quot;;
    // 第一步：初始化visited数组
    int visited[MAX_SIZE] = &#123;0&#125;;
    for (int i = 0; i &lt; G.vexNumber; i++) // 该for循环可以保证图在非连通状态下也能遍历！！！
    &#123;
        if (visited[i] == 0)
        &#123;
            result += DFS(G,i,visited);
        &#125;
    &#125;
    return result;
&#125;

int main()
&#123;
    Graph G;
    cin &gt;&gt; G.vexNumber;
    for (int i = 0; i &lt; G.vexNumber; i++)
    &#123;
        G.vexInfo[i] = to_string(i);
        for (int j = 0; j &lt; G.vexNumber; j++)
        &#123;
            cin &gt;&gt; G.adjMatrix[i][j];
        &#125;
    &#125;
    string str = DFS(G);
    cout &lt;&lt; str &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p><strong>输入样例</strong></p>
<pre><code class="c++">7
0 1 0 0 1 0 0
1 0 1 1 0 0 0
0 1 0 0 0 0 0
0 1 0 0 0 1 1
1 0 0 0 0 0 0
0 0 0 1 0 0 0
0 0 0 1 0 0 0
</code></pre>
<p><strong>输出样例</strong></p>
<pre><code class="c++">0 1 2 3 5 6 4
</code></pre>
<p><img src="E:\数据结构\期末复习\1b7df9ff433943eca387bc06b0c67ea4.png" alt="图片"></p>
<h5 id="3-2-BFS-广度优先遍历"><a href="#3-2-BFS-广度优先遍历" class="headerlink" title="3.2 BFS (广度优先遍历)"></a>3.2 BFS (广度优先遍历)</h5><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;

using namespace std;

#define MAX_SIZE 100

struct Graph
&#123;
    int vexNumber;
    string vexInfo[MAX_SIZE];
    int adjMatrix[MAX_SIZE][MAX_SIZE];
&#125;;

// 我写的这个BFS靠result获取遍历序列，故可以删去队列，也可通过入队出队操作获取输出序列
string BFS(const Graph &amp;G, int v0, int visited[])
&#123;
    string result = &quot;&quot;;

    queue&lt;int&gt; q;
    if (visited[v0] == 0)
    &#123;
        result = result + G.vexInfo[v0] + &quot; &quot;;
        visited[v0] = 1;
    &#125;
    q.push(v0);

    while (!q.empty())
    &#123;
        q.pop();

        for (int i = 0; i &lt; G.vexNumber; i++)
        &#123;
            if (G.adjMatrix[v0][i] == 1 &amp;&amp; visited[i] == 0)
            &#123;
                result = result + G.vexInfo[i] + &quot; &quot;;
                visited[i] = 1;
                q.push(i);
            &#125;
        &#125;   
    &#125;
    return result;
&#125;

string BFS(const Graph &amp;G)
&#123;
    string result = &quot;&quot;;
    // 第一步：初始化visited数组
    int visited[MAX_SIZE] = &#123;0&#125;;
    // 第二步：以每个未被遍历的顶点为起点，进行BFS
    for (int i = 0; i &lt; G.vexNumber; i++)  
    &#123;
        if (visited[i] == 0)
        &#123;
            result += BFS(G,i,visited);
        &#125;
    &#125;
    return result;
&#125;

int main()
&#123;
    Graph G;
    cin &gt;&gt; G.vexNumber;
    for (int i = 0; i &lt; G.vexNumber; i++)
    &#123;
        G.vexInfo[i] = to_string(i);
        for (int j = 0; j &lt; G.vexNumber; j++)
        &#123;
            cin &gt;&gt; G.adjMatrix[i][j];
        &#125;
    &#125;
    string str = BFS(G);
    cout &lt;&lt; str &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p><strong>输入样例</strong></p>
<pre><code class="c++">7
0 1 0 0 1 0 0
1 0 1 1 0 0 0
0 1 0 0 0 0 0
0 1 0 0 0 1 1
1 0 0 0 0 0 0
0 0 0 1 0 0 0
0 0 0 1 0 0 0
</code></pre>
<p><strong>输出样例</strong></p>
<pre><code>0 1 4 2 3 5 6 
</code></pre>
<p><img src="E:\数据结构\期末复习\1b7df9ff433943eca387bc06b0c67ea4.png" alt="图片"></p>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Welcome
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;EzraLi
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
